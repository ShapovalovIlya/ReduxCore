//
//  NotificationCenter.swift
//
//
//  Created by Илья Шаповалов on 15.05.2024.
//

import Foundation

public extension NotificationCenter {
    func stream(
        of name: Notification.Name,
        object: AnyObject? = nil
    ) -> NotificationCenter.Stream {
        Stream(self, name: name, object: object)
    }
}

public extension NotificationCenter {
    //MARK: - Stream
    /**
     An asynchronous sequence of notifications generated by a notification center.
     
     - Tip: The Notification type doesn’t conform to Sendable,
     so iterating over this asynchronous sequence produces a compiler warning.
     You can use a map(_:) or compactMap(_:) operator on the sequence to extract sendable properties of the notification
     and iterate over those instead.
     */
    final class Stream: AsyncSequence {
        public typealias Element = Notification
        
        //MARK: - Private properties
        private let center: NotificationCenter
        private let name: Notification.Name
        private let object: AnyObject?
        
        //MARK: - init(_:)
        init(
            _ center: NotificationCenter,
            name: Notification.Name,
            object: AnyObject?
        ) {
            self.center = center
            self.name = name
            self.object = object
            print(#function)
        }
        
        deinit {
            print(#function)
        }
        
        //MARK: - Public methods
        @inlinable
        public func makeAsyncIterator() -> Iterator {
            Iterator(stream: self)
        }
        
    }
}

public extension NotificationCenter.Stream {
    //MARK: - Iterator
    struct Iterator: AsyncIteratorProtocol {
        public typealias Element = Notification
        @usableFromInline let center: NotificationCenter
        @usableFromInline let name: Notification.Name
        @usableFromInline let object: AnyObject?
        
        @usableFromInline
        init(stream: NotificationCenter.Stream) {
            self.center = stream.center
            self.name = stream.name
            self.object = stream.object
        }
        
        /// Asynchronously advances to the next element and returns it, or ends the
        /// sequence if there is no next element.
        ///
        /// - Returns: The next element, if it exists, or `nil` to signal the end of
        ///   the sequence.
        public mutating func next() async -> Element? {
            await withCheckedContinuation { continuation in
                center.addObserver(forName: name, object: object, queue: .current) { notification in
                    continuation.resume(returning: notification)
                }
            }
        }
    }
}
