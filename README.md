# ReduxCore Swift: Unidirectional State ManagementReduxCore provides a robust, thread-safe, and observable architecture for managing application state in Swift. Inspired by Redux and The Composable Architecture, it enables predictable state updates, unidirectional data flow, and seamless integration with Swift Concurrency and Combine/SwiftUI.### Key Concepts	•	Store The central state container. It holds your application state, processes actions via a reducer, and notifies subscribers of state changes.         The store ensures thread safety using a dedicated dispatch queue and supports both strong (drivers) and weak (streamers) subscription models.	•	Reducer A pure function that takes the current state and an action, and mutates the state in response. Reducers make state transitions predictable and testable.	•	Graph A lightweight value type that encapsulates the current state and a dispatcher. It provides a type-safe interface for reading state and dispatching actions,         and is ideal for passing state and action capabilities to child components or views.	•	StateStreamer An asynchronous, thread-safe broadcaster for state updates. It uses Swift’s ‎⁠AsyncStream⁠ to emit state changes to multiple consumers,         supporting configurable buffering and automatic cleanup.### Features	•	Thread-safe state access and mutation	•	Observable state via ‎⁠@Published⁠ for SwiftUI/Combine integration	•	Asynchronous state streaming with configurable buffering	•	Strong and weak subscription models for flexible architecture	•	Unidirectional data flow with action dispatching	•	Dynamic member lookup for ergonomic state access## Example:```swift// Define your state and actionsstruct AppState {     var count: Int = 0 }enum AppAction { case increment, decrement }// Create a reducerlet reducer: (inout AppState, AppAction) -> Void = { state, action in    switch action {    case .increment:         state.count += 1            case .decrement:         state.count -= 1    }}// Initialize the storelet store = Store(initial: AppState(), reducer: reducer)// Dispatch actionsstore.dispatch(.increment)// Use asynchronous streaminglet streamer = StateStreamer<AppState>()store.subscribe(streamer)Task {    for await state in streamer.state {        print("Async state update: \(state.count)")    }}```## When to UseReduxCore is ideal for Swift applications that require:	•	Predictable, centralized state management	•	Unidirectional data flow	•	Integration with Swift Concurrency, SwiftUI, or Combine	•	Testable and modular state transitions	•	Multiple types of subscribers (strong/weak, sync/async)